#!/opt/local/bin/perl

use strict;
use Getopt::Long;
use Time::Local;

######################################################################
# 
# RCL Argos data cleanup: 
#
# -Reads a raw data file provided by the Argos system
#  -Converts the data fields from integers to floating point
#   (data are actually in Campbell Science FP2 format)
#  -Removes bad records by using the Checksum
#  -Removes any duplicates
#  -Recreates the timestamp (time that records were recorded on 
#   the logger)
#  -Outputs the records to Std Out (CSV foromat). 
#
# Usage: 
#
my ( $Usage ) = 

"Usage: perl argos_cleanup.pl --file RAWFILE

   RAWFILE - Name of the raw file to process
             (includes path)
          
 
";

#
# Argos raw data format (04-Mar-2016 onwards): 
#
# "Program;PTT;Satellite;Location date;Location class;Latitude;Longitude;Message date;Compression index;1;2;3;4;5;6;7;8;9;10;11;12;13;14;15"
# "3865;94061;K;;;;;2016/03/05 16:17:12;1;25155;29868;18691;18519;25659;17188;17459;17691;22884;9089;12626;"
###################################################################################################################################
# On Feb 20 2013 the tiltmeter was removed and the logger reprogrammed.  The datafields now look like this.
# 3865;94061;N;;;;;2013/02/20 15:58:46;1;17690;17223;25703;18792;17278;2500;9177;17502;27571;25118;24626;24581;24577;22784;2669;
#
#Below is the datatable from the logger showing the order of the samples.

#DataTable (RuapehuArgosData,1,-1)
#  ' Data to be sent to Argos satellite: 
#  ' Max is 31 bytes or 15 2-byte floats (FP2).
#  ' --- 1 - 5 -------------------
#  Sample (1,mtrDepthKTE,FP2)	#ARGOSFIELD 09
#  Sample (1,mtrDepthKT2,FP2)	#ARGOSFIELD 10
#  Sample (1,degLakeTemp,FP2)	#ARGOSFIELD 11
#  Sample (1,degLakeTem2,FP2)	#ARGOSFIELD 12
#  Sample (1,Rs_R0,FP2)  	#ARGOSFIELD 13
#  ' --- 6 - 10 ------------------
#  Sample (1,degPTemp,FP2)	#ARGOSFIELD 14
#  Sample (1,psiBoxRTO,FP2)	#ARGOSFIELD 15
#  Sample (1,vltBattery,FP2)	#ARGOSFIELD 16
#  Sample (1,nIntervalNo,FP2)	#ARGOSFIELD 17
#  Sample (1,fCheckSum,FP2) 	#ARGOSFIELD 18
#EndTable

#
# Declare some constants to represent the index of each useful data field from the raw file, 
# assuming they will be read in and split into a 0-based array.
# This makes it much easier to figure out what later code is doing, and also easier to change
# this code if the fields in the raw file should change at a later date.
# Note that I haven't added constants for the fields we don't need. 
# 
# Field Indicies:  These are in the order of the RuapehuArgosData table as listed above.
#
#### First 9 are generated by the Argos sstem:  #####
#
use constant FLD_PROGRAM_ID    =>  0;   # ( 3865 = Our program )
# 1 = PTT                                         ( 94061 = Our platform ID )
# 2 = Satellite
# 3 = Location date  }
# 4 = Location class } Empty - we don't get a location
# 5 = Latitude       }
# 6 = Longitude      }
use constant FLD_MESSAGE_DATE  => 7;   # Message date
# 8 = Compression index  ( Always seems to be 1 )
#
#### Remaining fields are our data:  #####
use constant FLD_DATA_START =>  9; ######### FIRST index of FP2-encoded data fields
use constant FLD_DATA_END   => 18; ######### LAST index of FP2-encoded data fields
# FP2-Encoded data fields: 
use constant FLD_DEPTH_KTE     =>  9;   # Lake Depth (m) was 11
use constant FLD_DEPTH_KT2     => 10;   # Lake Depth (m) was 11
use constant FLD_LAKE_TEMP     => 11;   # Lake Temp (Deg C) was 12
use constant FLD_LAKE_TEM2     => 12;   # Lake Temp (Deg C) was 12
use constant FLD_RS_R0         => 13;   # Logger Panel Temp (Deg C) was 10
use constant FLD_PANEL_TEMP    => 14;   # Logger Panel Temp (Deg C) was 10
use constant FLD_BOX_PRESSURE  => 15;   # Box Pressure (PSI) was 13
#use constant FLD_E_TILT        => 13;   # East Tilt Axis (u rad)
#use constant FLD_N_TILT        => 14;   # North Tilt Axis (u rad)
#use constant FLD_TILT_BATT     => 15;   # Tilt Meter Battery (volts)
#use constant FLD_DEPTH_KTE_MIN => 16;   # Max lake depth reading (20 second sampling window) (m)
#use constant FLD_DEPTH_KTE_MAX => 17;   # Min lake depth reading (20 second sampling window) (m)
#use constant FLD_DEPTH_KTE_SD  => 18;   # Std Dev of lake depth readings (20 second sampling window) (m)
#use constant FLD_DEPTH_RTO     => 19;   # Lake depth reading from RTO sensor (PSI)
use constant FLD_BATTERY       => 16;   # Battery (volts) was 9
use constant FLD_INTERVAL_NO   => 17;   # index of 15 minute sample interval into UTC day 
use constant FLD_CHECKSUM      => 18;   # Checksum (see CheckCheckSum sub for notes on how it's calculated)
#:
#
### Constants used in data conversions / corrections: ###
use constant PSI_TO_MBAR       => 68.9475; # To convert PSI to mBar, multiply by this.
use constant PSI_TO_DEPTH      => 0.7033;  # To convert PSI to m water dapth, multiply by this.
use constant RTO_TEMP_CORR     => 0.0045;  # RTO temperature correction factor: 
     # This constant is used to correct temperature effects in the atmospheric pressure reading
     # using the following formula: 
     #     [CorrectedRTO] = [RTO] - ([BoxTemp] * RTO_TEMP_CORR)
     #      (RTO pressure in PSI)
#
# J Cole-Baker / GNS Science / 2011
######################################################################




################# Get command line options: ############################################
my ( $Help, $RawFileName );
GetOptions(   'help|?'    => \$Help,
              'file|f=s'  => \$RawFileName  );
# If user specifies '-h', show Usage info:
if ( ($Help) || !($RawFileName) )
  { die($Usage); }
########################################################################################



#my (  $RawFile, $RawFileFound,
#      $Line, @RawRecord, @DecodedRecord, $FieldIndex,
#      @TSParts, $RecordOK, $LastTimeStamp, $ThisTimeStamp,
#      $AtmPressure, $DepthRTO                                 );

my (  $RawFile, $RawFileFound,
      $Line, @RawRecord, @DecodedRecord, $FieldIndex,
      @TSParts, $RecordOK, $LastTimeStamp, $ThisTimeStamp,
      $AtmPressure                                 );



##### Open the input file: ######
$RawFileFound = 1;   #  Flag to indicate whether a raw file was found
open($RawFile, "<$RawFileName") or $RawFileFound = 0;  # Open raw file
if ($RawFileFound == 0)  { MyDie( "Input file not found: $RawFileName \n", 1 ); }; 
##################################




##### Read the input file line by line: ######
$LastTimeStamp = "2000/01/01 00:00:00";

while (!eof($RawFile))   # For each line in the file...
  {
  ## Read a line: ##
  $Line = <$RawFile>;

  ## Split the line at ';': ##
  @RawRecord = split(/;/, $Line);
  
  ## Only process lines starting with "3865" (these are data lines). ## 
  if ($RawRecord[FLD_PROGRAM_ID] == "3865")
    {
    ## Get the receive date from the line data: ## 
    @TSParts = split(/ /, $RawRecord[FLD_MESSAGE_DATE]);
    $DecodedRecord[FLD_MESSAGE_DATE] = $TSParts[0] . " ";    # Time will be added later...
    
    ## Decode the FP2 data fields:  ##
    for $FieldIndex (FLD_DATA_START .. FLD_DATA_END)
      {  $DecodedRecord[$FieldIndex] = CSToFlt( $RawRecord[$FieldIndex] );  }

    ## Test the checksum for this record: ##
    $RecordOK = CheckCheckSum(@DecodedRecord);
    ## DEBUG ## $RecordOK  = 1;
    if ($RecordOK)    
      {
      # Checksum OK. Check for duplicates: 
      $ThisTimeStamp = $DecodedRecord[FLD_MESSAGE_DATE] . MakeLoggerTime($DecodedRecord[FLD_INTERVAL_NO]);

      if ($ThisTimeStamp ne $LastTimeStamp)
        {
	# Output the record if the timestamp has changed (Not a duplicate!):
	# Format: RecordDate,Battery,PanelTemp,... 
	#         DepthKTE,LakeTemp,AtmPressure,...
	#         EastTilt,NorthTilt,TiltBattery,...
	#         DepthKTEMin,DepthKTEMax,DepthKTEStdDev,DepthRTO
	#
	# Corrections: 
	# Box RTO: A temperature correction is applied to remove temperature signal from the 
	# RTO reading. 
	#
	$DecodedRecord[FLD_BOX_PRESSURE] = $DecodedRecord[FLD_BOX_PRESSURE] - ($DecodedRecord[FLD_PANEL_TEMP] * RTO_TEMP_CORR);
	# Conversions: 
	#  * AtmPressure is converted from PSI to mbar
	#  * RTO Depth is calculated by subtracting the box RTO reading 
	#    (atmospheric pressure correction) and converting from PSI
	#    to metres water (assumes fresh water). 
	$AtmPressure = $DecodedRecord[FLD_BOX_PRESSURE] * PSI_TO_MBAR;
#	$DepthRTO = ($DecodedRecord[FLD_DEPTH_RTO]-$DecodedRecord[FLD_BOX_PRESSURE]) * PSI_TO_DEPTH;
#	New parameters added at end to avoid disrupting plotting of current data
        print STDOUT $ThisTimeStamp . "," . 
                    sprintf("%0.2f",$DecodedRecord[FLD_BATTERY]) . "," . 
                    sprintf("%0.2f",$DecodedRecord[FLD_PANEL_TEMP]) . "," . 
                    sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KTE]) . "," . 
                    sprintf("%0.2f",$DecodedRecord[FLD_LAKE_TEMP]) . "," . 
                    sprintf("%0.2f",$AtmPressure) . "," . 
		   # sprintf("%0.2f",$AtmPressure) . "\n"; 
#                   sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KT2]) . "," . #  More sensitive sensor
                    sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KT2]*0.375) . "," . 
                    sprintf("%0.2f",$DecodedRecord[FLD_LAKE_TEM2]) . "\n"; 
                   # sprintf("%0.3f",$DecodedRecord[FLD_E_TILT]) . "," . 
                   # sprintf("%0.3f",$DecodedRecord[FLD_N_TILT]) . "," . 
                   # sprintf("%0.2f",$DecodedRecord[FLD_TILT_BATT]) . "," . 
                   # sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KTE_MIN]) . "," . 
                   # sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KTE_MAX]) . "," . 
                   # sprintf("%0.3f",$DecodedRecord[FLD_DEPTH_KTE_SD]) . "," . 
                   # sprintf("%0.3f",$DepthRTO) . "\n";
        $LastTimeStamp = $ThisTimeStamp;
        }
      }
    }
  }


## Finished with raw file. Close! ##
close($RawFile);

###### Finished! ##########################################################################








#%%%%%%%%%%%%% Subroutines: %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




##################################################################
sub MyDie
  {
  # Stop the script, and display a message if the 'Debug' parameter passed to 
  # the sub (second parameter) is True.
  # USAGE: MyDie( $Message, $Debug );
  my ( $Message, $Debug );
  $Message = $_[0];
  $Debug = $_[1];
  if ($Debug) { print STDERR $Message . "\n"; }
  die;
  }
##################################################################





##################################################################
sub CSToFlt
  {
  # Convert a string representing 16 bit unsigned intager,
  # which is ACTUALLY a 16-bit float in FP2 format, 
  # into an actual floating point value: 
  # 
  # USAGE: $MyFloat = CSToFlt( $IntStr );
  #
  my ($In, $Mant, $Expn, $Sign);  
  $In = int( $_[0] );
  ## Right-most bit (B15) of number is Sign bit: ##
  #   $Sign = -1 for negative numbers and 1 for positive numbers...
  $Sign = -2 * ($In >> 15) + 1;
  ## B14-B13 are power of 10 (i.e. multiplier): ##
  #   11 = 0.001
  #   10 = 0.01
  #   01 = 0.1
  #   00 = 1
  $Expn = 10**( -1 * ( ($In & 24576) >> 13) );
  ## Bits 12-0 are mantissa: ##
  $Mant = ($In & 8191);
  return  ($Mant * $Expn * $Sign);
  }
##################################################################






##################################################################
sub CheckCheckSum
  {
  # Check the checksum on an Argos record: 
  # 
  # USAGE: $MyResult = CheckCheckSum( @ArgosRecord );
  #  
  # Returns: 1 if the checksum matches the record; 0 if the checksum fails. 
  #
  # The ckecksum is a floating point number calculated on the logger as follows: 
  # Checksum = DEPTH_KTE + LAKE_TEMP + PANEL_TEMP + BOX_PRESSURE +
  #            (E_TILT / 1000) + (N_TILT / 1000) + TILT_BATT + 
  #            DEPTH_KTE_MIN + DEPTH_KTE_MAX + DEPTH_KTE_SD + DEPTH_RTO + FLD_BATTERY + 
  #           (INTERVAL_NO / 10)
  #
  # The checksum is sent at the last value in the record. This function 
  # recalc:wulates the checksum from the values which were received, and compares
  # the locally calculated checksum to the received checksum. 
  # A difference of no greater than 0.2 is tolerated, to allow for imprecision in the 
  # values transmitted by the FP2 format. If the difference in checksum is greater than 
  # this, the record is rejected (function returns 0). 
  #
  my ( @MyRecord, $MyCS, $MyCSDiff );
  @MyRecord = @_;
  # Calculate local checksum:
  $MyCS = $MyRecord[9] + $MyRecord[10] + $MyRecord[11] + $MyRecord[12] +
          $MyRecord[13] + $MyRecord[14] + $MyRecord[15] +
	  $MyRecord[16] + $MyRecord[17]/10;
  # Compare to transmitted checksum:
  $MyCSDiff = abs( $MyCS - $MyRecord[FLD_CHECKSUM] );
#  if ($MyCSDiff < 0.2) #changed the checksum difference requirement to 1 to see if that improves things. 
   if ($MyCSDiff < 0.2)
    {
    # Checksum OK: 
    return 1;    
    }
  else
    {
    # Checksum FAIL!
    return 0;   # changed by Tony Hurst to "1" to force check sum to be ok. Change back to "0" for normal operation. CM 8/5/12.
    }
  }
##################################################################







##################################################################
sub MakeLoggerTime
  {
  # Make a logger time in the format "HH:MM:SS" based on the 'interval no' 
  # field, which is the 15 minute interval of the day 
  # (i.e. 0 = 00:00:00, 1 = 00:15:00, 5 = 01:15:00, etc)
  #
  # Usage: $MyTimeString = MakeLoggerTime( $IntervalNo );
  my ( $Hours, $Minutes );
  $Hours = int( $_[0] / 4 );
  $Minutes = int( $_[0] % 4 ) * 15;
  return sprintf( "%02d:%02d:00", $Hours, $Minutes );
  }
##################################################################

  
  
  
